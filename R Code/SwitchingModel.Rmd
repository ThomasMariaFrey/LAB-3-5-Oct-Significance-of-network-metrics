Random graphs with the same degree sequence as the real graphs generated by the 
syntactic dependencies of  languages generated by the Switching Model

Set the working directory, load the requested libraries and obtain the source 
code.
```{r}
#Change to your working directoy
setwd("~/Desktop/University/CSN-MIRI Complex and Social Networks/Lab/LAB-3-5-Oct-Significance-of-network-metrics")

# Load required libraries
library(xtable)
library(data.table)
library(igraph)
```

Set the basic required variables
```{r}
# We had to remove czech because it kept throwing a fatal error
languages <- c("Arabic", "Basque", "Catalan", "Chinese",
               "English", "Greek", "Hungarian", "Italian", "Turkish")
# The number of switching models that are to be created and estimated. This 
# should be atleas 20
nSwitch <- 10
# The size of the switch graphs that are estimated.
Estimationpercentage <- 0.05
clusteringResults <- read.csv("../clustering_results.csv")
realClusteringCoefficientValues <- clusteringResults$RealNetworkClustering
# Removing the value for chzech
realClusteringCoefficientValues <- realClusteringCoefficientValues[-5]

```

P Value Calculation Function: This function uses the Monte Carlos simulation 
function that is used to compare the clustering coefficent of the switch model
graphs to the clustering coefficent of the original graphs. This is done by 
calculating the proportion of randomized graphs that have a clustering 
coefficent greater or equal thatn the original model.
```{r}
CalculatePValueForSwitching <- function(graph, realClusteringCoefficient){
  # Compute the number of nodes in the graph
  numNodesTotal <- vcount(graph)
  # Initializing the largerclust to 0
  largerClust <- 0
  # Create a switching model multiple times for a given time and graph
  # thereafter calculate the relevant clustering coefficient here
  for (i in seq(1,nSwitch)){
    # Create the graph
    switchingGraph <- createSwitchingGraph(graph)
    # Calculate the clustering coefficient
    switchClusteringCoefficient <- estimateGraphClusteringCoefficient(switchingGraph)
    # If the clustering coefficient of the switch model is larger than the 
    # clustering coefficient of the real graph increment largerClust by one
    if (switchClusteringCoefficient >= realClusteringCoefficient){
      largerClust = largerClust + 1
    } 
  }
  # Return the p value for the switching graph.
  return(largerClust/nSwitch)
}
```

Switching model Function: This function will modify the structure of original 
synthetic dependency networks by "switching" to create a new graph that
preserves the degree distribution of the orignal graph but is otherwise 
randomized. This is done by calculating valid edge switches. Valid means
that it does not create loops or multiple edges. There after the switches are
applied. We then calculate the clustering coefficient by wattz and strogatz.
The switchin model should have no influence on the local clustering coefficient.
```{r}
createSwitchingGraph <-function(graph){
    edgeData = as_edgelist(graph, names = FALSE)
    E = nrow(edgeData)

    # This has to be done to ensure that the larger graphs can be loaded into 
    # memory, setting sparse to false
    adjacendcyMatrix = as_adjacency_matrix(graph, names = FALSE, type = "both", sparse=FALSE)
    
    # Coupon calculation, ensuring that it is larger than 10 for the best value
    minQ <- 10
    Q <- log(E)
    if(minQ > Q){
      Q <- minQ
    }
    # The amount of switches that will be done should be log(E) * E
    switchesAmount <- Q * E 
    
    # We obtain an initial amount of edges for that the nodes shall be switched.
    firstEdgeIndices = sample(1:E, switchesAmount, replace = TRUE)
    secondEdgeIndices = sample(1:E, switchesAmount, replace = TRUE)
    
    # Doing the switchesAmount of switches to permute the real graph into a 
    # switch graph
    for (idx in seq(1, switchesAmount)) {
        firstEdge = edgeData[firstEdgeIndices[idx],]
        secondEdge = edgeData[secondEdgeIndices[idx],]
        
        origFirstEdge = firstEdge
        origSecondEdge = secondEdge
        
        # Make sure that all edges are different and there are no redundant 
        # edges present so that a successfull switch can be made
        if (all(firstEdge != secondEdge) && adjacendcyMatrix[secondEdge[1], firstEdge[2]] == 0 && adjacendcyMatrix[firstEdge[2], secondEdge[1]] == 0 && adjacendcyMatrix[firstEdge[2], secondEdge[1]] == 0 && adjacendcyMatrix[firstEdge[1], secondEdge[2]] == 0 && adjacendcyMatrix[secondEdge[2], firstEdge[1]] == 0) {
            
            #Switch the first and second edge
            swapped = firstEdge[2]
            firstEdge[2] = secondEdge[2]
            secondEdge[2] = swapped
            edgeData[firstEdgeIndices[idx],] = firstEdge
            edgeData[secondEdgeIndices[idx],] = secondEdge
            
            #Delete the old adjacencies
            adjacendcyMatrix[origFirstEdge[1], origFirstEdge[2]] = 0
            adjacendcyMatrix[origFirstEdge[2], origFirstEdge[1]] = 0
            adjacendcyMatrix[origSecondEdge[1], origSecondEdge[2]] = 0
            adjacendcyMatrix[origSecondEdge[2], origSecondEdge[1]] = 0
            
            #Create the new adjacencies
            adjacendcyMatrix[firstEdge[1], firstEdge[2]] = 1
            adjacendcyMatrix[firstEdge[2], firstEdge[1]] = 1
            adjacendcyMatrix[secondEdge[1], secondEdge[2]] = 1
            adjacendcyMatrix[secondEdge[2], secondEdge[1]] = 1
        }
    }
    # Recreate the graph from the edgelist and return it 
    randomizedSwitchGraph<-graph_from_edgelist(edgeData, directed = FALSE)
    return(randomizedSwitchGraph)
}
```


Estimate Graph Clustering Coefficient Function: We estimate the clustering 
coefficent for a subset of nodes and the average this value to obtain an 
estimate of the overall closeness metric.
```{r}
estimateGraphClusteringCoefficient <- function(graph){
  # Counting the amount of nodes to be considered
  nodesAmount <- vcount(graph)
  # Computing the sample size of the graph
  sampleSize = nodesAmount * Estimationpercentage
  # Selecting the nodes to be sampled
  selectedNodes <- sample(V(graph), size = sampleSize)
  # Calculating the clustering coefficient of the selected samples
  localClusteringCoefficients <- transitivity(graph, vids=selectedNodes, type = "local")
  # Replacing all Nan values with 0. Nan values are these with less than two 
  # edges
  localClusteringCoefficients[is.nan(localClusteringCoefficients)] <- 0
  # Calculating the mean local clustering coefficient for return
  averageClusteringCoefficient <- mean(localClusteringCoefficients)
  return(averageClusteringCoefficient)
}
```

Running the switching model
```{r}
# i for selecting the relevant real clustering coefficient values to compare
# against
i <- 1
# Vector for stroring th c values
pvalues <- c()
# The amount of iterations that will be done, should be at least 20 for a real 
# run
print("Amount of iterations: ")
print(nSwitch)
# For all languages except czech because that one causes RStudio to crash
for (lang in languages) {
  # Create the relevant path
  file_name <- paste0("../data/", lang, "_syntactic_dependency_network.txt")
  # Read in the table
  edgeData <- read.table(file_name, skip = 1, header = FALSE, stringsAsFactors = FALSE, quote = "", sep = " ", na.strings = "")
  # Create a basic graph
  graph = graph.data.frame(edgeData)
  # Remove potential multiples and loops in the graph
  graph = simplify(graph,remove.multiple = TRUE,remove.loops = TRUE)
  # Extract the real clustering coefficient value for the current language
  relevantResult <- realClusteringCoefficientValues[i]
  # Use the switching methods to calculate the p value
  pvalue <- CalculatePValueForSwitching(graph,relevantResult)
  # Append to pvalue list
  pvalues <- c(pvalues, pvalue)
  # Safe the calculated values in a txt file
  write(pvalues, file = "pvalues50.txt")
  i <- i+1
}
# Create a df with all pvalues
pvalueswitchdf <- data.frame(Languages = languages, PValues = pvalues)
# Write these values into a csv
write.csv(pvalueswitchdf, file = "switchpvalues.csv", row.names = FALSE)

```


############################## Time testing below ############################## 

Testing the of different orderings of vertices for estimating the p value of distributions 
The relevant orderings are: Original ordering, Random ordering of vertices, Increasing order by degree, decreasing order by degree. They will be tested by speed. This will be done with the Basque language as it is the smallest one

```{r}
  # Create the relevant path
  file_name <- paste0("../data/", "Basque", "_syntactic_dependency_network.txt")
  # Read in the table
  edgeData <- read.table(file_name, skip = 1, header = FALSE, stringsAsFactors = FALSE, quote = "", sep = " ", na.strings = "")
  # Create a basic graph
  graph = graph.data.frame(edgeData)
  # Remove potential multiples and loops in the graph
  graph = simplify(graph,remove.multiple = TRUE,remove.loops = TRUE)
  # Extract the real clustering coefficient value for the current language
  relevantResult <- 0.078
  # Use the switching methods to calculate the p value
  pvalue <- timeTestCalculatePValueForSwitching(graph,relevantResult)
  # Append to pvalue list
  pvalues <- c(pvalues, pvalue)
  # Safe the calculated values in a txt file
  write(pvalues, file = "pvaluesSpeedTest.txt")
```

Functions for the time tests
```{r}
timeTestCalculatePValueForSwitching <- function(graph, realClusteringCoefficient){
  # Compute the number of nodes in the graph
  numNodesTotal <- vcount(graph)
  # Initializing the largerclust to 0
  largerClust <- 0
  timings <- numeric()
  # Create a switching model multiple times for a given time and graph
  # thereafter calculate the relevant clustering coefficient here
  start_time_1<-proc.time()
  for (i in seq(1,nSwitch)){
    # Create the graph
    switchingGraph <- createSwitchingGraph(graph)
    # Calculate the clustering coefficient
    switchClusteringCoefficient <- timeTestORIGINALestimateGraphClusteringCoefficient(switchingGraph)
    # If the clustering coefficient of the switch model is larger than the 
    # clustering coefficient of the real graph increment largerClust by one
    if (switchClusteringCoefficient >= realClusteringCoefficient){
      largerClust = largerClust + 1
    } 
  }
  end_time_1<-proc.time()
  elapsed_time <- end_time_1[3] - start_time_1[3]
  timings <- c(timings, elapsed_time)
  
  start_time_2<-proc.time()
    for (i in seq(1,nSwitch)){
    # Create the graph
    switchingGraph <- createSwitchingGraph(graph)
    # Calculate the clustering coefficient
    switchClusteringCoefficient <- timeTestRANDOMestimateGraphClusteringCoefficient(switchingGraph)
    # If the clustering coefficient of the switch model is larger than the 
    # clustering coefficient of the real graph increment largerClust by one
    if (switchClusteringCoefficient >= realClusteringCoefficient){
      largerClust = largerClust + 1
    } 
  }
  end_time_2<-proc.time()
  elapsed_time <- end_time_2[3] - start_time_2[3]
  timings <- c(timings, elapsed_time)
  
    start_time_3<-proc.time()
    for (i in seq(1,nSwitch)){
    # Create the graph
    switchingGraph <- createSwitchingGraph(graph)
    # Calculate the clustering coefficient
    switchClusteringCoefficient <- timeTestASCENDINGestimateGraphClusteringCoefficient(switchingGraph)
    # If the clustering coefficient of the switch model is larger than the 
    # clustering coefficient of the real graph increment largerClust by one
    if (switchClusteringCoefficient >= realClusteringCoefficient){
      largerClust = largerClust + 1
    } 
  }
  end_time_3<-proc.time()
  elapsed_time <- end_time_3[3] - start_time_3[3]
  timings <- c(timings, elapsed_time)
  
      start_time_4<-proc.time()
    for (i in seq(1,nSwitch)){
    # Create the graph
    switchingGraph <- createSwitchingGraph(graph)
    # Calculate the clustering coefficient
    switchClusteringCoefficient <- timeTestDECENDINGestimateGraphClusteringCoefficient(switchingGraph)
    # If the clustering coefficient of the switch model is larger than the 
    # clustering coefficient of the real graph increment largerClust by one
    if (switchClusteringCoefficient >= realClusteringCoefficient){
      largerClust = largerClust + 1
    } 
  }
  end_time_4<-proc.time()
  elapsed_time <- end_time_4[3] - start_time_4[3]
  timings <- c(timings, elapsed_time)
  
  print(timings)
  write.table(timings, file = "timings.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
  
  # Return the p value for the switching graph.
  return(largerClust/nSwitch)
}
```


Estimation functions for the graph clustering coefficient given different sampleing strategies.
```{r}
timeTestORIGINALestimateGraphClusteringCoefficient <- function(graph){
  # Counting the amount of nodes to be considered
  nodesAmount <- vcount(graph)
  # Computing the sample size of the graph
  sampleSize = nodesAmount * Estimationpercentage
  # Selecting the nodes to be sampled ORIGINALLY
  selectedNodes <- V(graph)[1:sampleSize]
  # Calculating the clustering coefficient of the selected samples
  localClusteringCoefficients <- transitivity(graph, vids=selectedNodes, type = "local")
  # Replacing all Nan values with 0. Nan values are these with less than two 
  # edges
  localClusteringCoefficients[is.nan(localClusteringCoefficients)] <- 0
  # Calculating the mean local clustering coefficient for return
  averageClusteringCoefficient <- mean(localClusteringCoefficients)
  return(averageClusteringCoefficient)
}

timeTestRANDOMestimateGraphClusteringCoefficient <- function(graph){
  # Counting the amount of nodes to be considered
  nodesAmount <- vcount(graph)
  # Computing the sample size of the graph
  sampleSize = nodesAmount * Estimationpercentage
  # Selecting the nodes to be sampled RANDOMLY
  selectedNodes <- sample(V(graph), size = sampleSize)
  # Calculating the clustering coefficient of the selected samples
  localClusteringCoefficients <- transitivity(graph, vids=selectedNodes, type = "local")
  # Replacing all Nan values with 0. Nan values are these with less than two 
  # edges
  localClusteringCoefficients[is.nan(localClusteringCoefficients)] <- 0
  # Calculating the mean local clustering coefficient for return
  averageClusteringCoefficient <- mean(localClusteringCoefficients)
  return(averageClusteringCoefficient)
}

timeTestASCENDINGestimateGraphClusteringCoefficient <- function(graph){
  # Counting the amount of nodes to be considered
  nodesAmount <- vcount(graph)
  # Computing the sample size of the graph
  sampleSize = nodesAmount * Estimationpercentage
  # Selecting the nodes to be sampled ASCENDINGLY
  ordered_nodes <- order(degree(graph))
  selectedNodes <- ordered_nodes[1:sampleSize]
  # Calculating the clustering coefficient of the selected samples
  localClusteringCoefficients <- transitivity(graph, vids=selectedNodes, type = "local")
  # Replacing all Nan values with 0. Nan values are these with less than two 
  # edges
  localClusteringCoefficients[is.nan(localClusteringCoefficients)] <- 0
  # Calculating the mean local clustering coefficient for return
  averageClusteringCoefficient <- mean(localClusteringCoefficients)
  return(averageClusteringCoefficient)
}

timeTestDECENDINGestimateGraphClusteringCoefficient <- function(graph){
  # Counting the amount of nodes to be considered
  nodesAmount <- vcount(graph)
  # Computing the sample size of the graph
  sampleSize = nodesAmount * Estimationpercentage
  # Selecting the nodes to be sampled DECENDINGLY
  ordered_nodes <- order(-degree(graph))
  selectedNodes <- ordered_nodes[1:sampleSize]
  # Calculating the clustering coefficient of the selected samples
  localClusteringCoefficients <- transitivity(graph, vids=selectedNodes, type = "local")
  # Replacing all Nan values with 0. Nan values are these with less than two 
  # edges
  localClusteringCoefficients[is.nan(localClusteringCoefficients)] <- 0
  # Calculating the mean local clustering coefficient for return
  averageClusteringCoefficient <- mean(localClusteringCoefficients)
  return(averageClusteringCoefficient)
}

```



