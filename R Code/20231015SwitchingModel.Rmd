TODO:
study clustering coefficient for 10 differnt language and compare them to the null models er and switching method with p
1. define clustering coefficient
2. propertie table of the degree sequences
3. calculate clustering coefficent for all languages and according p values for binomial and switching and put them in a table
4. discuss the results
Extra: Use igraph

Load the required packages and set working directory
```{r}
library("data.table")
library("ggplot2")
library("igraph")
library("knitr")
library("rstudioapi")
library("xtable")
#Set your own working directory here if necessary
setwd("~/Desktop/University/CSN-MIRI Complex and Social Networks/Lab/Lab3/R Code")
```

Function to generate the metrics table
```{r}
createMetricsData <- function(languageList) {
    resultData <- data.table(
        "Language" = character(),
        "Nodes" = numeric(),
        "Edges" = numeric(),
        "AvgDegree" = numeric(),
        "Density" = numeric(),
        stringsAsFactors = FALSE
    )
    
    for (i in seq_along(languageList)) {
        currentLanguage <- languageList[i]
        dataPath <- paste("../data/", currentLanguage, "_syntactic_dependency_network.txt", sep = "")
        # The words in the database are sepeerated by spaces in all cases.
        degreeData = read.table(
            dataPath,
            header = FALSE,
            stringsAsFactors = FALSE,
            sep = " ",
            quote = ""
        )
        # Unsure if there is any missing data, perhaps we can delete this code.
        degreeData = na.omit(degreeData)
        
        graphNetwork = graph.data.frame(degreeData[-1,])
        # Removing multuple and loops here already.
        graphNetwork = simplify(graphNetwork, remove.multiple = TRUE, remove.loops = TRUE)
        
        #The amount of edges in the notebook
        E = gsize(graphNetwork)
        totalNodes = as.numeric(degreeData[1, 1])
        
        #These are the formulas from the lecture
        avgDeg = 2 * E / totalNodes
        density = 2 * E / (totalNodes * (totalNodes - 1))
        
        # Creating the property table
        resultData <- rbind(resultData, list(currentLanguage, totalNodes, E, avgDeg, density))
        
        outputDataPath <- paste(currentLanguage, "_syntactic_dependency_network.txt", sep = "")
        write_graph(graphNetwork, outputDataPath, format = "edgelist")
    }
    return(resultData)
}

```

Generate the metrics table
```{r}
#All lists of relevance
languageList = c(
    "Arabic",
    "Basque",
    "Catalan",
    "Chinese",
    "Czech",
    "English",
    "Greek",
    "Hungarian",
    "Italian",
    "Turkish"
)
metrics_table = createMetricsData(languageList)
print(metrics_table)
```

Calculate mean local clusterin as defined by watts & strogatz
```{r}

compute_clustering <- function(dataPath) {
    raw_data <- readLines(dataPath)
    if (length(raw_data) <= 1) {
        return(NA)
    }
    # Remove the header
    header <- as.numeric(strsplit(raw_data[1], " ")[[1]])
    # Split the remaining data by given space and structure into two columns
    edge_data <- do.call("rbind", lapply(raw_data[-1], function(line) {
        parts <- unlist(strsplit(line, " ", fixed = TRUE))
        return(c(parts[1], paste(parts[-1], collapse = " ")))
    }))
    edge_data <- as.data.frame(edge_data, stringsAsFactors = FALSE)

    # Construct a graph
    graph_network <- graph.data.frame(edge_data, directed = FALSE)
    # Might not be necessary as we are doing this before
    graphNetwork = simplify(graphNetwork, remove.multiple = TRUE, remove.loops = TRUE)
    
    # Compute the clustering coefficient for each node, this is in accordance
    # to the requested wz model.
    clustering_coefficients <- transitivity(graph_network, type = "local")
    
    # Return the mean clustering coefficient
    return(mean(clustering_coefficients, na.rm = TRUE))
}

# Run the function
clustering_results <- list()

for (i in seq_along(languageList)) {
    currentLanguage <- languageList[i]
    dataPath <- paste("../data/", currentLanguage, "_syntactic_dependency_network.txt", sep = "")
    
    clustering_results[[currentLanguage]] <- compute_clustering(dataPath)
}

print(clustering_results)
#Might want to put them in a latex table here


```
Clusterin results
```{r}
# Convert the list to a data frame
df <- data.frame(
    Language = names(clustering_results),
    ClusteringCoefficient = unlist(clustering_results)
)

# Print the data frame
print(df)

#TODO ADD the actual values here later
df$`p-value for ER` <- NA
df$`p-value for switching model` <- NA

```

Function for creating randomized Graphs with the switching model from the given languages ATTEMPT 1 Does not work
```{r}
# Function to perform a single switching attempt
switch_edges <- function(graph) {
    # Randomly select two edges
    eids <- sample(E(graph), 2)
    e1 <- ends(graph, eids[1])
    e2 <- ends(graph, eids[2])
    
    # Try rewiring
    if(e1[1] != e2[1] && e1[1] != e2[2] && e1[2] != e2[1] && e1[2] != e2[2]) {
        # Potential new edges
        new1 <- c(e1[1], e2[2])
        new2 <- c(e1[2], e2[1])
        # Check if potential new edges already exist in the graph
        if(!are_adjacent(graph, new1[1], new1[2]) && !are_adjacent(graph, new2[1], new2[2])) {
            graph <- delete_edges(graph, eids)
            graph <- add_edges(graph, c(new1, new2))
        }
    }
    return(graph)
}
```

Creating randomized Graphs with the switching model from the given languages
ATTEMPT 1 DOES NOT WORK
```{r}
for (i in seq_along(languageList)) {
    currentLanguage <- languageList[i]
    dataPath <- paste("../data/", currentLanguage, "_syntactic_dependency_network.txt", sep = "")
    #edges <- read.table(dataPath, stringsAsFactors = FALSE)
    degreeData = read.table(
      dataPath,
      header = FALSE,
      stringsAsFactors = FALSE,
      sep = " ",
      quote = ""
    )
    
    # Construct the graph
    g <- graph_from_data_frame(edges, directed = TRUE)
    
    # Set Q based on your preference or use the coupon collector's problem formula
    Q <- 10 # Adjust this value as needed
    
    # Randomize the graph using the switching model
    E <- ecount(g)
    for(j in 1:(Q*E)) {
        g <- switch_edges(g)
    }
    
    # Here, you have a randomized graph g with the same degree sequence as the original one
    # You can analyze it, plot it, or save it as needed
}

```

Function for creating randomized Graphs with the switching model from the given languages ATTEMPT 2
```{r}
generateRandomSwitchGraph <- function(inputGraph) {
    successTries = 0
    rejectedTries = 0
    edgeData = as_edgelist(inputGraph, names = FALSE)
    
    E = nrow(edgeData)
    Q = 10 #TODO do coupon calculation here, should be the given value though
    
    # Creating an adjecenty matrix here
    adjMatrix = as_adjacency_matrix(inputGraph, names = FALSE, type = "both")
    matrixStyle = as.matrix(adjMatrix)
    
    firstEdgeIndices = sample(1:E, Q * E, replace = TRUE)
    secondEdgeIndices = sample(1:E, Q * E, replace = TRUE)
    
    for (idx in seq(1, E * Q)) {
        firstEdge = edgeData[firstEdgeIndices[idx], ]
        secondEdge = edgeData[secondEdgeIndices[idx], ]
        
        origFirstEdge = firstEdge
        origSecondEdge = secondEdge
        
        if (all(firstEdge != secondEdge) && 
            matrixStyle[secondEdge[1], firstEdge[2]] == 0 &&
            matrixStyle[firstEdge[2], secondEdge[1]] == 0 &&
            matrixStyle[firstEdge[1], secondEdge[2]] == 0 &&
            matrixStyle[secondEdge[2], firstEdge[1]] == 0) {
            
            swapped = firstEdge[2]
            firstEdge[2] = secondEdge[2]
            secondEdge[2] = swapped
            
            edgeData[firstEdgeIndices[idx], ] = firstEdge
            edgeData[secondEdgeIndices[idx], ] = secondEdge
            
            matrixStyle[origFirstEdge[1], origFirstEdge[2]] = 0
            matrixStyle[origSecondEdge[1], origSecondEdge[2]] = 0
            matrixStyle[origFirstEdge[2], origFirstEdge[1]] = 0
            matrixStyle[origSecondEdge[2], origSecondEdge[1]] = 0
            
            matrixStyle[firstEdge[1], firstEdge[2]] = 1
            matrixStyle[secondEdge[1], secondEdge[2]] = 1
            matrixStyle[firstEdge[2], firstEdge[1]] = 1
            matrixStyle[secondEdge[2], secondEdge[1]] = 1
            
            successTries = successTries + 1
        } else {
            rejectedTries = rejectedTries + 1
        }
    }
    cat("Rejected Attempts: ", rejectedTries, "\n")
    cat("Successful Switches: ", successTries, "\n")
    randomizedSwitchGraph = graph_from_edgelist(edgeData, directed = FALSE)
    return(randomizedSwitchGraph)
}


```

Create randomized graphs using the switching the model
```{r}
createSwitchGraphs <- function(languages) {
    for (langIndex in seq_along(languages)) {
        currentLanguageuage <- languages[langIndex]
        cat("Processing:", currentLanguageuage, "\n")
        
        dataPath <- file.path("..", "data", paste0(currentLanguageuage, "_syntactic_dependency_network.txt"))
        
        dataEntries <- read.table(
            dataPath,
            header = FALSE,
            stringsAsFactors = FALSE,
            sep = " ",
            quote = ""
        )
        
        dataEntries <- na.omit(dataEntries)
        
        languageGraph <- graph.data.frame(dataEntries[-1,])
        languageGraph <- simplify(languageGraph, remove.multiple = TRUE, remove.loops = TRUE)
        
        # This requires a large amount of memory
        randomizedSwitchGraph <- generateRandomSwitchGraph(languageGraph)
        
        print(randomizedSwitchGraph)
        
        # Save the switched graph
        savePath <- file.path("switchgraphs", paste0(currentLanguageuage, "_switched_graph.txt"))
        write_graph(randomizedSwitchGraph, savePath, format = "edgelist")
    }
}

# Assuming languageList is defined
createSwitchGraphs(languageList)

```
